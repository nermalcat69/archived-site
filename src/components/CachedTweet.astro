---
type TweetTheme = 'light' | 'dark';

export interface Props {
  id: string;
  theme?: TweetTheme;
}

const { id, theme = 'light' } = Astro.props;

// Extract tweet ID from URL
function extractTweetId(url: string): string {
  const match = url.match(/status\/(\d+)/);
  return match ? match[1] : url;
}

// Cache key for the tweet
const tweetId = extractTweetId(id);
const cacheKey = `tweet_${tweetId}_${theme}`;

// Function to fetch tweet with caching
async function fetchCachedTweet(id: string, theme: TweetTheme) {
  try {
    // Build-time caching - this runs during build
    const oembedUrl = new URL('https://publish.twitter.com/oembed');
    oembedUrl.searchParams.set('url', id);
    oembedUrl.searchParams.set('omit_script', 'true');
    oembedUrl.searchParams.set('dnt', 'true');
    oembedUrl.searchParams.set('theme', theme);
    
    const response = await fetch(oembedUrl);
    
    if (!response.ok) {
      console.warn(`Failed to fetch tweet ${id}: ${response.status}`);
      return null;
    }
    
    const tweetData = await response.json() as {
      url: string;
      author_name: string;
      author_url: string;
      html: string;
    };
    
    return tweetData;
  } catch (error) {
    console.error(`Error fetching tweet ${id}:`, error);
    return null;
  }
}

const tweet = await fetchCachedTweet(id, theme);
---

{tweet ? (
  <div class="cached-tweet" data-tweet-id={tweetId} data-theme={theme}>
    <div set:html={tweet.html} />
  </div>
) : (
  <div class="tweet-fallback" data-tweet-id={tweetId}>
    <p>
      <a href={id} target="_blank" rel="noopener noreferrer">
        View tweet on X/Twitter
      </a>
    </p>
  </div>
)}

<script>
  // Client-side caching and enhancement
  class TweetCache {
    private static cache = new Map<string, any>();
    private static readonly CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours
    private static readonly STORAGE_KEY = 'tweet_cache';

    static init() {
      // Load cache from localStorage on page load
      this.loadFromStorage();
      
      // Set up periodic cache cleanup
      this.scheduleCleanup();
    }

    static getCacheKey(tweetId: string, theme: string): string {
      return `${tweetId}_${theme}`;
    }

    static set(tweetId: string, theme: string, data: any): void {
      const key = this.getCacheKey(tweetId, theme);
      const cacheEntry = {
        data,
        timestamp: Date.now(),
        tweetId,
        theme
      };
      
      this.cache.set(key, cacheEntry);
      this.saveToStorage();
    }

    static get(tweetId: string, theme: string): any | null {
      const key = this.getCacheKey(tweetId, theme);
      const entry = this.cache.get(key);
      
      if (!entry) return null;
      
      // Check if cache entry is still valid
      if (Date.now() - entry.timestamp > this.CACHE_DURATION) {
        this.cache.delete(key);
        this.saveToStorage();
        return null;
      }
      
      return entry.data;
    }

    static loadFromStorage(): void {
      try {
        const stored = localStorage.getItem(this.STORAGE_KEY);
        if (!stored) return;
        
        const parsed = JSON.parse(stored);
        
        // Validate and load cache entries
        for (const [key, entry] of Object.entries(parsed)) {
          if (this.isValidCacheEntry(entry)) {
            this.cache.set(key, entry);
          }
        }
      } catch (error) {
        console.warn('Failed to load tweet cache from localStorage:', error);
        localStorage.removeItem(this.STORAGE_KEY);
      }
    }

    static saveToStorage(): void {
      try {
        const cacheObject = Object.fromEntries(this.cache);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(cacheObject));
      } catch (error) {
        console.warn('Failed to save tweet cache to localStorage:', error);
      }
    }

    static isValidCacheEntry(entry: any): boolean {
      return entry && 
             typeof entry.timestamp === 'number' && 
             typeof entry.tweetId === 'string' && 
             typeof entry.theme === 'string' && 
             entry.data;
    }

    static scheduleCleanup(): void {
      // Clean up expired entries every hour
      setInterval(() => {
        const now = Date.now();
        let cleaned = false;
        
        for (const [key, entry] of this.cache.entries()) {
          if (now - entry.timestamp > this.CACHE_DURATION) {
            this.cache.delete(key);
            cleaned = true;
          }
        }
        
        if (cleaned) {
          this.saveToStorage();
        }
      }, 60 * 60 * 1000); // 1 hour
    }

    static getCacheStats(): { size: number; entries: string[] } {
      return {
        size: this.cache.size,
        entries: Array.from(this.cache.keys())
      };
    }
  }

  // Initialize cache system
  TweetCache.init();

  // Enhanced tweet loading for fallbacks
  document.addEventListener('DOMContentLoaded', () => {
    const fallbackTweets = document.querySelectorAll('.tweet-fallback');
    
    fallbackTweets.forEach(async (fallback) => {
      const tweetId = fallback.getAttribute('data-tweet-id');
      if (!tweetId) return;
      
      // Try to load from cache first
      const cached = TweetCache.get(tweetId, 'light');
      if (cached) {
        fallback.innerHTML = cached.html;
        fallback.classList.add('loaded-from-cache');
        return;
      }
      
      // If not in cache and we're online, try to fetch
      if (navigator.onLine) {
        try {
          const response = await fetch(`/api/tweet/${tweetId}`);
          if (response.ok) {
            const tweetData = await response.json();
            fallback.innerHTML = tweetData.html;
            TweetCache.set(tweetId, 'light', tweetData);
            fallback.classList.add('loaded-dynamically');
          }
        } catch (error) {
          console.warn(`Failed to dynamically load tweet ${tweetId}:`, error);
        }
      }
    });
  });

  // Log cache stats in development
  if (import.meta.env.DEV) {
    console.log('Tweet Cache Stats:', TweetCache.getCacheStats());
  }
</script>

<style>
  .cached-tweet {
    margin: 1rem 0;
  }

  .tweet-fallback {
    margin: 1rem 0;
    padding: 1rem;
    border: 1px solid var(--gray-6);
    border-radius: 0.5rem;
    background: var(--gray-2);
    text-align: center;
  }

  .tweet-fallback a {
    color: var(--blue-9);
    text-decoration: none;
  }

  .tweet-fallback a:hover {
    text-decoration: underline;
  }

  .loaded-from-cache {
    border-color: var(--green-6);
  }

  .loaded-dynamically {
    border-color: var(--blue-6);
  }

  /* Twitter widget styling */
  .cached-tweet :global(.twitter-tweet) {
    margin: 0 auto !important;
  }

  /* Dark mode support */
  [data-theme="dark"] .tweet-fallback {
    background: var(--gray-1);
    border-color: var(--gray-7);
  }
</style>